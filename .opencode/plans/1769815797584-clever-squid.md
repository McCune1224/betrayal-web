# Backend Testing System Setup Plan

## Overview
Set up a comprehensive testing infrastructure using testify and pgx/v5 PostgreSQL driver. This includes adding missing dependencies, creating stub implementations for compilation, setting up test helpers, and establishing testing patterns.

## Current State
- testify v1.11.1: Already installed in go.mod
- pgx/v5: Configured in sqlc.yaml but NOT in go.mod
- Missing packages: internal.InitDB, game package, handlers package (referenced in main.go)
- db.go is empty
- Only 1 example test exists

## Goals
1. Add pgx/v5 and supporting dependencies to go.mod
2. Create stub implementations for all missing packages so code compiles
3. Set up test infrastructure with database helpers and fixtures
4. Create comprehensive test examples using testify
5. Set up migration framework for schema management

## Implementation Steps

### Phase 1: Dependencies
**Files:** `backend/go.mod`
- Add `github.com/jackc/pgx/v5 v5.7.1` (PostgreSQL driver)
- Add `github.com/jackc/pgx/v5/pgxpool` (connection pooling)
- Add `github.com/gorilla/websocket v1.5.3` (WebSocket support)
- Add `github.com/golang-migrate/migrate/v4 v4.18.1` (migrations)
- Run `go mod tidy`

### Phase 2: Database Connection Setup
**Files:** `backend/internal/db/db.go`
- Create database connection using pgxpool
- Implement InitDB(ctx, connString) function
- Implement CloseDB(ctx) function
- Add connection health check
- Support both production and test database URLs

### Phase 3: Test Infrastructure
**Files:** 
- `backend/internal/testutil/testutil.go` - Test utilities
- `backend/internal/testutil/db.go` - Database test helpers

Create test utilities:
- SetupTestDB() - Initialize test database connection
- TeardownTestDB() - Cleanup test database
- RunMigrations(testDB) - Run migrations on test DB
- TruncateTables(testDB) - Clean data between tests
- LoadFixture(testDB, fixtureName) - Load test data

### Phase 4: Migration Setup
**Files:**
- `backend/internal/db/migrations/001_create_initial_schema.up.sql`
- `backend/internal/db/migrations/001_create_initial_schema.down.sql`

Initial schema should include:
- rooms table (id, code, host_id, phase, created_at, updated_at)
- players table (id, room_id, name, role_id, is_alive, joined_at)
- actions table (id, room_id, player_id, type, target_id, phase, timestamp)
- roles table (id, name, description, team)

### Phase 5: Stub Implementations
**Files:**
- `backend/internal/game/room.go` - Room management
- `backend/internal/game/hub.go` - WebSocket hub
- `backend/internal/handlers/rooms.go` - HTTP handlers
- `backend/internal/handlers/ws.go` - WebSocket handlers
- `backend/internal/handlers/health.go` - Health check handler
- `backend/internal/models/types.go` - Shared types

These are stub implementations to make the code compile. Full implementation is outside scope.

### Phase 6: Test Examples
**Files:**
- `backend/internal/db/db_test.go` - Database connection tests
- `backend/internal/game/room_test.go` - Room management tests
- `backend/internal/handlers/rooms_test.go` - HTTP handler tests
- `backend/internal/testutil/db_test.go` - Test utility tests

Test patterns to demonstrate:
- testify/assert for non-fatal assertions
- testify/require for fatal assertions
- testify/suite for test suites
- Table-driven tests with multiple test cases
- Database integration tests with test helpers
- Mock usage for WebSocket testing

### Phase 7: SQLC Integration
**Files:** `backend/internal/db/query/queries.sql`
- Update queries.sql with actual game queries
- Run `sqlc generate` to generate type-safe Go code
- Create `backend/internal/db/sqlc/` directory for generated code

## Key Testing Patterns

### 1. Unit Tests with Testify
```go
func TestRoomManager_CreateRoom(t *testing.T) {
    rm := NewRoomManager()
    code := rm.CreateRoom("host-123")
    
    assert.NotEmpty(t, code, "room code should be generated")
    assert.Len(t, code, 6, "room code should be 6 characters")
}
```

### 2. Table-Driven Tests
```go
func TestValidateRoomCode(t *testing.T) {
    tests := []struct {
        name    string
        code    string
        wantErr bool
    }{
        {"valid uppercase", "ABC123", false},
        {"valid lowercase", "abc123", false},
        {"too short", "ABC12", true},
        {"too long", "ABC1234", true},
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            err := ValidateRoomCode(tt.code)
            if tt.wantErr {
                assert.Error(t, err)
            } else {
                assert.NoError(t, err)
            }
        })
    }
}
```

### 3. Database Integration Tests
```go
func TestPlayerRepository_Create(t *testing.T) {
    testDB := testutil.SetupTestDB(t)
    defer testutil.TeardownTestDB(t, testDB)
    
    repo := NewPlayerRepository(testDB)
    player, err := repo.Create(context.Background(), "Alice", "ROOM01")
    
    require.NoError(t, err)
    assert.NotNil(t, player)
    assert.Equal(t, "Alice", player.Name)
    assert.Equal(t, "ROOM01", player.RoomCode)
}
```

### 4. Test Suites with Setup/Teardown
```go
type RoomHandlerTestSuite struct {
    suite.Suite
    handler *RoomHandler
    testDB  *pgxpool.Pool
}

func (s *RoomHandlerTestSuite) SetupSuite() {
    s.testDB = testutil.SetupTestDB(&s.Suite)
    s.handler = NewRoomHandler(s.testDB)
}

func (s *RoomHandlerTestSuite) TearDownSuite() {
    testutil.TeardownTestDB(&s.Suite, s.testDB)
}

func (s *RoomHandlerTestSuite) SetupTest() {
    testutil.TruncateTables(s.testDB)
}
```

## File Structure After Implementation

```
backend/
├── go.mod                          # Updated with pgx/v5 and deps
├── go.sum                          # Updated
├── sqlc.yaml                       # Existing
├── cmd/server/main.go              # References now compile
├── internal/
│   ├── example_test.go             # Existing
│   ├── models/
│   │   └── types.go                # Shared types
│   ├── db/
│   │   ├── db.go                   # Database connection (pgx/v5)
│   │   ├── db_test.go              # Connection tests
│   │   ├── migrations/
│   │   │   ├── 001_create_initial_schema.up.sql
│   │   │   └── 001_create_initial_schema.down.sql
│   │   ├── query/
│   │   │   └── queries.sql         # sqlc queries
│   │   └── sqlc/                   # Generated by sqlc
│   ├── game/
│   │   ├── room.go                 # Stub implementation
│   │   ├── room_test.go            # Room tests
│   │   └── hub.go                  # Stub implementation
│   ├── handlers/
│   │   ├── rooms.go                # HTTP handlers
│   │   ├── rooms_test.go           # Handler tests
│   │   ├── ws.go                   # WebSocket handlers
│   │   └── health.go               # Health check
│   └── testutil/
│       ├── testutil.go             # Test utilities
│       ├── db.go                   # Database test helpers
│       └── db_test.go              # Test for helpers
```

## Verification

After implementation, verify by running:

```bash
cd backend

# 1. Verify compilation
go build ./...

# 2. Run all tests
go test ./... -v

# 3. Run with coverage
go test ./... -cover

# 4. Run specific package tests
go test ./internal/game/... -v
go test ./internal/handlers/... -v
go test ./internal/db/... -v

# 5. Verify database integration tests use test database
go test ./internal/db/... -v -run TestIntegration

# 6. Generate sqlc code
go generate ./...
# or
sqlc generate
```

## Environment Variables

Ensure these are set for tests:
- `TEST_DATABASE_URL` - Required for integration tests
- `DATABASE_URL` - For production/development

## Success Criteria

- [ ] `go build ./...` compiles successfully
- [ ] `go test ./...` runs without errors
- [ ] testify is used in all new tests
- [ ] pgx/v5 is properly integrated with connection pooling
- [ ] Test helpers support database integration testing
- [ ] Migration framework is set up
- [ ] sqlc generates type-safe Go code
- [ ] Coverage reports can be generated

## Notes

- All stub implementations will compile but may not be fully functional
- Full implementation of game logic is outside this plan's scope
- Tests should be written to demonstrate patterns and verify stubs
- Test database should be isolated from production database
- Consider using testcontainers-go for integration tests in CI/CD
